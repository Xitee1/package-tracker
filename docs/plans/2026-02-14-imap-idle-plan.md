# IMAP IDLE & Polling Redesign — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Rewrite the IMAP worker to support true persistent IDLE connections with polling as a user-controllable fallback, including capability detection and frontend controls.

**Architecture:** Dual-mode worker with separate `_idle_loop()` and `_poll_loop()` inner loops wrapped by an outer reconnection loop. IDLE capability is detected on every connect via `CAPABILITY` response. New `use_polling` and `idle_supported` fields on `EmailAccount` control mode selection. Frontend exposes a "Use polling" toggle that is greyed out when IDLE is unsupported.

**Tech Stack:** FastAPI, SQLAlchemy 2.0 async, aioimaplib (idle_start/wait_server_push/idle_done), Alembic, Vue 3 Composition API, Pinia, vue-i18n

---

### Task 1: Alembic Migration — Add use_polling and idle_supported columns

**Files:**
- Create: `backend/alembic/versions/<auto>_add_idle_support_fields.py` (via autogenerate)
- Modify: `backend/app/models/email_account.py:10-26`

**Step 1: Add columns to EmailAccount model**

In `backend/app/models/email_account.py`, add two fields to the `EmailAccount` class after `polling_interval_sec` (line 21):

```python
use_polling: Mapped[bool] = mapped_column(Boolean, default=False)
idle_supported: Mapped[Optional[bool]] = mapped_column(Boolean, nullable=True, default=None)
```

Also change the default for `polling_interval_sec` from `120` to `300`:

```python
polling_interval_sec: Mapped[int] = mapped_column(Integer, default=300)
```

Add `Optional` to the typing import at line 2:

```python
from typing import Optional
```

(Already imported — verify it's there.)

**Step 2: Generate Alembic migration**

Run from `backend/`:

```bash
cd /home/mato/projects/tools/package-tracker/backend && alembic revision --autogenerate -m "add idle support fields to email_accounts"
```

**Step 3: Review and edit the generated migration**

The migration should contain:
- `op.add_column('email_accounts', sa.Column('use_polling', sa.Boolean(), nullable=False, server_default=sa.text('false')))`
- `op.add_column('email_accounts', sa.Column('idle_supported', sa.Boolean(), nullable=True))`
- `op.alter_column('email_accounts', 'polling_interval_sec', server_default=sa.text('300'))`

And the downgrade should reverse these. Review the autogenerated file and adjust if needed. Remove `server_default` after the column is created if desired (matches existing pattern).

**Step 4: Run migration to verify**

```bash
cd /home/mato/projects/tools/package-tracker && docker compose exec backend alembic upgrade head
```

Or if running locally:

```bash
cd /home/mato/projects/tools/package-tracker/backend && alembic upgrade head
```

**Step 5: Commit**

```bash
git add backend/app/models/email_account.py backend/alembic/versions/
git commit -m "feat(backend): add use_polling and idle_supported to EmailAccount model"
```

---

### Task 2: Update Schemas and Account API

**Files:**
- Modify: `backend/app/schemas/email_account.py:5-36`
- Modify: `backend/app/api/accounts.py:27-57,69-84`

**Step 1: Write failing tests for new schema fields and validation**

Add to `backend/tests/test_accounts.py`:

```python
@pytest.mark.asyncio
async def test_create_account_has_idle_fields(client, admin_token):
    """New accounts should return use_polling and idle_supported."""
    resp = await client.post("/api/v1/accounts", json=ACCOUNT_DATA, headers=auth(admin_token))
    assert resp.status_code == 201
    data = resp.json()
    assert data["use_polling"] is False
    assert data["idle_supported"] is None


@pytest.mark.asyncio
async def test_update_use_polling(client, admin_token):
    """Should allow toggling use_polling."""
    create = await client.post("/api/v1/accounts", json=ACCOUNT_DATA, headers=auth(admin_token))
    account_id = create.json()["id"]
    resp = await client.patch(
        f"/api/v1/accounts/{account_id}",
        json={"use_polling": True},
        headers=auth(admin_token),
    )
    assert resp.status_code == 200
    assert resp.json()["use_polling"] is True


@pytest.mark.asyncio
async def test_reject_disable_polling_when_idle_unsupported(client, admin_token, db_session):
    """Should reject use_polling=false when idle_supported=false."""
    create = await client.post("/api/v1/accounts", json=ACCOUNT_DATA, headers=auth(admin_token))
    account_id = create.json()["id"]
    # Simulate worker detecting no IDLE support
    from app.models.email_account import EmailAccount
    account = await db_session.get(EmailAccount, account_id)
    account.idle_supported = False
    account.use_polling = True
    await db_session.commit()
    # Try to disable polling
    resp = await client.patch(
        f"/api/v1/accounts/{account_id}",
        json={"use_polling": False},
        headers=auth(admin_token),
    )
    assert resp.status_code == 400
    assert "IMAP IDLE" in resp.json()["detail"]
```

**Step 2: Run tests to verify they fail**

```bash
cd /home/mato/projects/tools/package-tracker/backend && python -m pytest tests/test_accounts.py::test_create_account_has_idle_fields tests/test_accounts.py::test_update_use_polling tests/test_accounts.py::test_reject_disable_polling_when_idle_unsupported -v
```

Expected: FAIL (fields missing from response, no validation)

**Step 3: Update schemas**

In `backend/app/schemas/email_account.py`:

`CreateAccountRequest` (line 5) — add field:
```python
use_polling: bool = False
```

`UpdateAccountRequest` (line 15) — add field:
```python
use_polling: Optional[bool] = None
```

`AccountResponse` (line 26) — add fields:
```python
use_polling: bool
idle_supported: Optional[bool] = None
```

Change default in `CreateAccountRequest`:
```python
polling_interval_sec: int = 300
```

**Step 4: Update account creation in API**

In `backend/app/api/accounts.py`, `create_account()` (line 29), add to the `EmailAccount()` constructor:

```python
use_polling=req.use_polling,
```

**Step 5: Add validation to account update in API**

In `backend/app/api/accounts.py`, `update_account()` (line 46), before the `for field, value` loop, add:

```python
if req.use_polling is False and account.idle_supported is False:
    raise HTTPException(
        status_code=400,
        detail="This email provider does not support IMAP IDLE",
    )
```

**Step 6: Update test connection to check IDLE capability**

In `backend/app/api/accounts.py`, `test_connection()` (lines 69-84), after the login succeeds, check capability:

```python
try:
    password = decrypt_value(account.imap_password_encrypted)
    if account.use_ssl:
        mail = imaplib.IMAP4_SSL(account.imap_host, account.imap_port)
    else:
        mail = imaplib.IMAP4(account.imap_host, account.imap_port)
    mail.login(account.imap_user, password)
    # Check IDLE capability
    _, caps = mail.capability()
    capabilities = caps[0].decode().upper().split() if caps else []
    idle_supported = "IDLE" in capabilities
    mail.logout()
    return {"success": True, "message": "Connection successful", "idle_supported": idle_supported}
except Exception as e:
    return {"success": False, "message": str(e), "idle_supported": None}
```

**Step 7: Run tests to verify they pass**

```bash
cd /home/mato/projects/tools/package-tracker/backend && python -m pytest tests/test_accounts.py -v
```

Expected: ALL PASS

**Step 8: Commit**

```bash
git add backend/app/schemas/email_account.py backend/app/api/accounts.py backend/tests/test_accounts.py
git commit -m "feat(backend): add use_polling/idle_supported to schemas and API with validation"
```

---

### Task 3: Rewrite IMAP Worker — Helper Functions

**Files:**
- Modify: `backend/app/services/imap_worker.py`

This task extracts shared logic into helper functions before writing the new loops.

**Step 1: Add new imports and constants**

At the top of `backend/app/services/imap_worker.py`, add/update imports:

```python
from aioimaplib import IMAP4_SSL, STOP_WAIT_SERVER_PUSH
```

Add constants after the `h2t` setup (line 22):

```python
IDLE_TIMEOUT_SEC = 24 * 60  # 24 minutes, safely under RFC 2177's 29-minute limit
MAX_BACKOFF_SEC = 300  # 5 minutes
```

**Step 2: Write `_connect_and_select()` helper**

Add after `_get_effective_settings()` (after line 110):

```python
async def _connect_and_select(
    account: EmailAccount, folder: WatchedFolder, db
) -> tuple[IMAP4_SSL, bool]:
    """Connect, login, check IDLE capability, select folder. Returns (imap_client, idle_supported)."""
    from app.core.encryption import decrypt_value

    password = decrypt_value(account.imap_password_encrypted)
    imap = IMAP4_SSL(host=account.imap_host, port=account.imap_port)
    await imap.wait_hello_from_server()
    await imap.login(account.imap_user, password)

    # Check IDLE capability (must check after login — some servers only advertise post-auth)
    idle_supported = imap.has_capability("IDLE")

    # Update idle_supported in DB; force use_polling if IDLE not supported
    if account.idle_supported != idle_supported:
        account.idle_supported = idle_supported
        if not idle_supported and not account.use_polling:
            account.use_polling = True
            logger.info(
                f"Account {account.id}: IDLE not supported, forcing polling mode"
            )
        await db.commit()
        await db.refresh(account)

    select_response = await imap.select(folder.folder_path)

    # UIDVALIDITY check
    max_age, delay, check_uid = await _get_effective_settings(db, folder)
    if check_uid:
        current_uidvalidity = None
        if select_response and len(select_response) > 1:
            for line in select_response[1]:
                line_str = line.decode() if isinstance(line, bytes) else str(line)
                match = re.search(r"UIDVALIDITY\s+(\d+)", line_str)
                if match:
                    current_uidvalidity = int(match.group(1))
                    break

        if current_uidvalidity is not None:
            if folder.uidvalidity is None:
                folder.uidvalidity = current_uidvalidity
                await db.commit()
            elif folder.uidvalidity != current_uidvalidity:
                logger.warning(
                    f"UIDVALIDITY changed for folder {folder.id}: "
                    f"{folder.uidvalidity} -> {current_uidvalidity}. Resetting."
                )
                folder.uidvalidity = current_uidvalidity
                folder.last_seen_uid = 0
                await db.commit()

    return imap, idle_supported
```

**Step 3: Write `_fetch_new_emails()` helper**

Add after `_connect_and_select()`:

```python
async def _fetch_new_emails(
    imap: IMAP4_SSL, account: EmailAccount, folder: WatchedFolder,
    db, state: WorkerState | None,
) -> None:
    """UID search for new emails, process and enqueue them."""
    max_age, delay, _ = await _get_effective_settings(db, folder)
    since_date = (datetime.now(timezone.utc) - timedelta(days=max_age)).strftime("%d-%b-%Y")
    search_criteria = f"UID {folder.last_seen_uid + 1}:* SINCE {since_date}"
    _, data = await imap.uid_search(search_criteria)
    uids = data[0].split() if data[0] else []

    if state:
        if uids:
            state.mode = WorkerMode.PROCESSING
            state.queue_total = len(uids)
        state.last_activity_at = datetime.now(timezone.utc)

    for i, uid_bytes in enumerate(uids):
        uid = int(uid_bytes)
        if uid <= folder.last_seen_uid:
            continue

        _, msg_data = await imap.uid("fetch", str(uid), "(RFC822)")
        if not msg_data or not msg_data[0]:
            continue

        raw_email = None
        for part in msg_data:
            if isinstance(part, bytearray):
                raw_email = bytes(part)
                break
        if raw_email is None:
            continue
        msg = email.message_from_bytes(raw_email)

        subject = _decode_header_value(msg.get("Subject", ""))
        sender = _decode_header_value(msg.get("From", ""))
        message_id = msg.get("Message-ID", "")
        body = _extract_body(msg)

        email_date = None
        try:
            date_str = msg.get("Date", "")
            if date_str:
                from email.utils import parsedate_to_datetime
                email_date = parsedate_to_datetime(date_str)
        except Exception:
            pass

        if state:
            state.queue_position = i + 1
            state.current_email_subject = subject
            state.current_email_sender = sender
            state.last_activity_at = datetime.now(timezone.utc)

        # Dedup check
        existing = await db.execute(
            select(ProcessedEmail).where(ProcessedEmail.message_id == message_id)
        )
        if existing.scalar_one_or_none():
            folder.last_seen_uid = uid
            await db.commit()
            continue

        queue_item = QueueItem(
            user_id=account.user_id,
            status="queued",
            source_type="email",
            source_info=f"{account.imap_user} / {folder.folder_path}",
            raw_data={
                "subject": subject,
                "sender": sender,
                "body": body,
                "message_id": message_id,
                "email_uid": uid,
                "email_date": email_date.isoformat() if email_date else None,
            },
        )
        db.add(queue_item)
        await db.flush()

        processed = ProcessedEmail(
            account_id=account.id,
            folder_path=folder.folder_path,
            email_uid=uid,
            message_id=message_id,
            queue_item_id=queue_item.id,
        )
        db.add(processed)

        folder.last_seen_uid = uid
        await db.commit()

        if delay > 0:
            await asyncio.sleep(delay)

    if state:
        state.last_scan_at = datetime.now(timezone.utc)
        state.clear_queue()
```

**Step 4: Commit helpers**

```bash
git add backend/app/services/imap_worker.py
git commit -m "refactor(backend): extract _connect_and_select and _fetch_new_emails helpers"
```

---

### Task 4: Rewrite IMAP Worker — IDLE and Polling Loops

**Files:**
- Modify: `backend/app/services/imap_worker.py`

**Step 1: Write `_idle_loop()`**

Add after `_fetch_new_emails()`:

```python
async def _idle_loop(
    imap: IMAP4_SSL, account: EmailAccount, folder: WatchedFolder,
    db, state: WorkerState | None,
) -> None:
    """Persistent IDLE loop. Returns only on connection error (to trigger reconnect)."""
    while True:
        if state:
            state.mode = WorkerMode.IDLE
            state.next_scan_at = None
            state.last_activity_at = datetime.now(timezone.utc)

        try:
            idle_task = await imap.idle_start(timeout=IDLE_TIMEOUT_SEC)

            msg = await imap.wait_server_push()

            if msg == STOP_WAIT_SERVER_PUSH:
                # 24-minute timeout — re-issue IDLE (no new mail)
                imap.idle_done()
                await asyncio.wait_for(idle_task, timeout=5)
                continue

            # Got a real notification (EXISTS, EXPUNGE, etc.)
            imap.idle_done()
            await asyncio.wait_for(idle_task, timeout=5)

            # Check if it's an EXISTS notification (new mail)
            has_new = False
            if isinstance(msg, list):
                for line in msg:
                    line_str = line.decode() if isinstance(line, bytes) else str(line)
                    if "EXISTS" in line_str:
                        has_new = True
                        break

            if has_new:
                await _fetch_new_emails(imap, account, folder, db, state)

        except asyncio.CancelledError:
            raise
        except Exception as e:
            logger.warning(f"IDLE loop error for folder {folder.id}: {e}")
            try:
                imap.idle_done()
            except Exception:
                pass
            return  # Break to outer reconnect loop
```

**Step 2: Write `_poll_loop()`**

Add after `_idle_loop()`:

```python
async def _poll_loop(
    account_id: int, folder_id: int, state: WorkerState | None,
) -> None:
    """Polling loop. Disconnects between cycles. Returns on connection error."""
    while True:
        if state:
            state.mode = WorkerMode.POLLING
            state.next_scan_at = datetime.now(timezone.utc) + timedelta(
                seconds=max(account_polling_interval, 60)
            )

        await asyncio.sleep(account_polling_interval)

        try:
            async with async_session() as db:
                account = await db.get(EmailAccount, account_id)
                folder = await db.get(WatchedFolder, folder_id)
                if not account or not folder or not account.is_active:
                    return

                imap, _ = await _connect_and_select(account, folder, db)
                await _fetch_new_emails(imap, account, folder, db, state)
                try:
                    await imap.logout()
                except Exception:
                    pass

                # Update interval in case it changed
                account_polling_interval = account.polling_interval_sec

        except asyncio.CancelledError:
            raise
        except Exception as e:
            logger.warning(f"Poll cycle error for folder {folder_id}: {e}")
            return  # Break to outer reconnect loop
```

Wait — the `_poll_loop` needs to read `account.polling_interval_sec` but may not have it in scope. Let me revise. The function should accept `account_id` and `folder_id` and open a fresh DB session each cycle (since it disconnects between cycles). Here is the corrected version:

```python
async def _poll_loop(
    account_id: int, folder_id: int, polling_interval_sec: int,
    state: WorkerState | None,
) -> None:
    """Polling loop. Disconnects between cycles. Returns on connection error."""
    interval = polling_interval_sec
    while True:
        if state:
            state.mode = WorkerMode.POLLING
            state.next_scan_at = datetime.now(timezone.utc) + timedelta(seconds=interval)

        await asyncio.sleep(interval)

        try:
            async with async_session() as db:
                account = await db.get(EmailAccount, account_id)
                folder = await db.get(WatchedFolder, folder_id)
                if not account or not folder or not account.is_active:
                    return

                imap, _ = await _connect_and_select(account, folder, db)
                await _fetch_new_emails(imap, account, folder, db, state)
                try:
                    await imap.logout()
                except Exception:
                    pass

                # Pick up any interval changes for next cycle
                interval = account.polling_interval_sec

        except asyncio.CancelledError:
            raise
        except Exception as e:
            logger.warning(f"Poll cycle error for folder {folder_id}: {e}")
            return  # Break to outer reconnect loop
```

**Step 3: Rewrite `_watch_folder()` as the outer reconnection loop**

Replace the entire `_watch_folder()` function (lines 113-307) with:

```python
async def _watch_folder(account_id: int, folder_id: int):
    """Watch a single IMAP folder using IDLE (persistent) or polling (periodic)."""
    backoff = 30

    while True:
        state = _worker_state.get(folder_id)
        if state:
            state.mode = WorkerMode.CONNECTING
            state.next_scan_at = None
            state.clear_queue()
            state.error = None

        try:
            async with async_session() as db:
                account = await db.get(EmailAccount, account_id)
                folder = await db.get(WatchedFolder, folder_id)
                if not account or not folder or not account.is_active:
                    logger.info(f"Stopping watcher for folder {folder_id}: inactive or removed")
                    return

                imap, idle_supported = await _connect_and_select(account, folder, db)

                # Initial fetch of new emails
                await _fetch_new_emails(imap, account, folder, db, state)

                # Reset backoff on successful connect + fetch
                backoff = 30

                if not account.use_polling and idle_supported:
                    # IDLE mode — persistent connection
                    await _idle_loop(imap, account, folder, db, state)
                else:
                    # Polling mode — disconnect first, then loop
                    try:
                        await imap.logout()
                    except Exception:
                        pass
                    await _poll_loop(account_id, folder_id, account.polling_interval_sec, state)

        except asyncio.CancelledError:
            logger.info(f"Watcher cancelled for folder {folder_id}")
            return
        except Exception as e:
            logger.error(f"Error watching folder {folder_id}: {e}")
            if state:
                state.mode = WorkerMode.ERROR_BACKOFF
                state.error = str(e)
                state.next_scan_at = datetime.now(timezone.utc) + timedelta(seconds=backoff)

        # Exponential backoff before reconnect
        await asyncio.sleep(backoff)
        backoff = min(backoff * 2, MAX_BACKOFF_SEC)
```

**Step 4: Verify the existing public functions still work**

The functions `start_all_watchers()`, `stop_all_watchers()`, `restart_watchers()`, `restart_single_watcher()`, and `is_folder_scanning()` (lines 309-368) should NOT need changes — they call `_watch_folder()` which has the same signature.

**Step 5: Commit**

```bash
git add backend/app/services/imap_worker.py
git commit -m "feat(backend): rewrite IMAP worker with persistent IDLE and polling loops"
```

---

### Task 5: Update Frontend Types and Store

**Files:**
- Modify: `frontend/src/stores/accounts.ts:5-16,18-26,28-37`

**Step 1: Update TypeScript types**

In `frontend/src/stores/accounts.ts`, add fields to `EmailAccount` type (after `is_active` around line 14):

```typescript
use_polling: boolean
idle_supported: boolean | null
```

Add to `CreateAccountPayload` (after `polling_interval_sec` around line 25):

```typescript
use_polling?: boolean
```

Add to `UpdateAccountPayload` (after `polling_interval_sec` around line 35):

```typescript
use_polling?: boolean
```

**Step 2: Commit**

```bash
git add frontend/src/stores/accounts.ts
git commit -m "feat(frontend): add use_polling and idle_supported to account types"
```

---

### Task 6: Add i18n Keys

**Files:**
- Modify: `frontend/src/i18n/locales/en.json:181-231`
- Modify: `frontend/src/i18n/locales/de.json:181-231`

**Step 1: Add English keys**

In `frontend/src/i18n/locales/en.json`, add inside the `"accounts"` object (before the closing `}`):

```json
"usePolling": "Use polling",
"usePollingTooltip": "Force periodic scanning instead of push notifications",
"idleNotSupported": "This email provider does not support push notifications (IMAP IDLE)",
"idleDetecting": "Will be detected on first connection",
"folderLimitWarning": "Watching many folders requires one connection per folder. Some providers limit concurrent connections.",
"idleNotSupportedReject": "This email provider does not support IMAP IDLE",
"modeIdle": "IDLE",
"modePolling": "Polling",
"modeDetecting": "Detecting..."
```

**Step 2: Add German keys**

In `frontend/src/i18n/locales/de.json`, add inside the `"accounts"` object:

```json
"usePolling": "Polling verwenden",
"usePollingTooltip": "Erzwingt periodisches Scannen anstelle von Push-Benachrichtigungen",
"idleNotSupported": "Dieser E-Mail-Anbieter unterstützt keine Push-Benachrichtigungen (IMAP IDLE)",
"idleDetecting": "Wird bei der ersten Verbindung erkannt",
"folderLimitWarning": "Die Überwachung vieler Ordner erfordert eine Verbindung pro Ordner. Einige Anbieter begrenzen die gleichzeitigen Verbindungen.",
"idleNotSupportedReject": "Dieser E-Mail-Anbieter unterstützt kein IMAP IDLE",
"modeIdle": "IDLE",
"modePolling": "Polling",
"modeDetecting": "Erkennung..."
```

**Step 3: Commit**

```bash
git add frontend/src/i18n/locales/en.json frontend/src/i18n/locales/de.json
git commit -m "feat(frontend): add i18n keys for IDLE/polling mode controls"
```

---

### Task 7: Update AccountsView — Mode Badge on Account Cards

**Files:**
- Modify: `frontend/src/views/AccountsView.vue:221-230`

**Step 1: Add mode badge next to the Active/Inactive badge**

In `frontend/src/views/AccountsView.vue`, after the `is_active` badge (line 230, after the closing `</span>` of the active badge), add:

```html
<span
  class="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium"
  :class="{
    'bg-green-100 dark:bg-green-900/40 text-green-800 dark:text-green-400': !account.use_polling && account.idle_supported === true,
    'bg-blue-100 dark:bg-blue-900/40 text-blue-800 dark:text-blue-400': account.use_polling,
    'bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-400': account.idle_supported === null && !account.use_polling,
  }"
  :title="account.idle_supported === null ? $t('accounts.idleDetecting') : ''"
>
  {{
    account.use_polling
      ? $t('accounts.modePolling')
      : account.idle_supported === true
        ? $t('accounts.modeIdle')
        : $t('accounts.modeDetecting')
  }}
</span>
```

**Step 2: Commit**

```bash
git add frontend/src/views/AccountsView.vue
git commit -m "feat(frontend): add IDLE/Polling mode badge on account cards"
```

---

### Task 8: Update AccountsView — Use Polling Toggle in Form

**Files:**
- Modify: `frontend/src/views/AccountsView.vue:110-134` (form section)
- Modify: `frontend/src/views/AccountsView.vue:538-546,565-574,586-594` (script — form state)

**Step 1: Add `use_polling` to form state**

In the `form` ref (around line 538), add:

```typescript
use_polling: false,
```

In `resetForm()` (around line 565), add:

```typescript
use_polling: false,
```

In `openEditForm()` (around line 586), add to the assignment:

```typescript
use_polling: account.use_polling,
```

In `handleSubmit()` (around line 609), add `use_polling` to the data object sent for updates:

```typescript
use_polling: form.value.use_polling,
```

**Step 2: Add the toggle UI after the SSL checkbox**

In the template, after the SSL checkbox block (after line 134), add:

```html
<div class="flex items-center gap-2">
  <div class="relative inline-flex items-center">
    <input
      id="use_polling"
      v-model="form.use_polling"
      type="checkbox"
      :disabled="editingId ? (accountBeingEdited?.idle_supported === false || accountBeingEdited?.idle_supported === null) : false"
      class="h-4 w-4 text-blue-600 border-gray-300 dark:border-gray-600 rounded focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
    />
    <label
      for="use_polling"
      class="text-sm font-medium text-gray-700 dark:text-gray-300 ml-2"
      :class="{ 'opacity-50': editingId && (accountBeingEdited?.idle_supported === false || accountBeingEdited?.idle_supported === null) }"
    >
      {{ $t('accounts.usePolling') }}
    </label>
  </div>
  <div
    v-if="editingId && accountBeingEdited?.idle_supported === false"
    class="text-xs text-amber-600 dark:text-amber-400"
    :title="$t('accounts.idleNotSupported')"
  >
    {{ $t('accounts.idleNotSupported') }}
  </div>
  <div
    v-else-if="editingId && accountBeingEdited?.idle_supported === null"
    class="text-xs text-gray-500 dark:text-gray-400"
    :title="$t('accounts.idleDetecting')"
  >
    {{ $t('accounts.idleDetecting') }}
  </div>
  <div
    v-else
    class="text-xs text-gray-500 dark:text-gray-400"
  >
    {{ $t('accounts.usePollingTooltip') }}
  </div>
</div>
```

**Step 3: Add `accountBeingEdited` computed**

In the `<script setup>` section, add a computed to look up the current account being edited:

```typescript
import { ref, computed, onMounted } from 'vue'

const accountBeingEdited = computed(() => {
  if (!editingId.value) return null
  return accountsStore.accounts.find((a) => a.id === editingId.value) ?? null
})
```

**Step 4: Commit**

```bash
git add frontend/src/views/AccountsView.vue
git commit -m "feat(frontend): add 'Use polling' toggle to account form"
```

---

### Task 9: Add Watched Folder Warning

**Files:**
- Modify: `frontend/src/views/AccountsView.vue:347-369` (folder management section)

**Step 1: Add warning when 10+ folders watched**

In the folder management expanded section, after the `folderError` div (around line 376), add:

```html
<div
  v-if="watchedFolders.length >= 10"
  class="bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-800 text-amber-700 dark:text-amber-400 px-3 py-2 rounded-md text-sm mb-4"
>
  {{ $t('accounts.folderLimitWarning') }}
</div>
```

**Step 2: Commit**

```bash
git add frontend/src/views/AccountsView.vue
git commit -m "feat(frontend): add connection limit warning for many watched folders"
```

---

### Task 10: Update Existing Tests for New Defaults

**Files:**
- Modify: `backend/tests/test_accounts.py:16-24`

**Step 1: Update ACCOUNT_DATA to match new default**

The `ACCOUNT_DATA` dict in `backend/tests/test_accounts.py` has `polling_interval_sec: 120`. This still works (it's an explicit value, not relying on defaults), but update the test for `test_create_account` to also verify the new fields are present.

Also verify existing tests still pass with the model changes:

```bash
cd /home/mato/projects/tools/package-tracker/backend && python -m pytest tests/ -v
```

Expected: ALL PASS

**Step 2: Commit if any test fixes were needed**

```bash
git add backend/tests/
git commit -m "test(backend): update account tests for idle support fields"
```

---

### Task 11: Build and Smoke Test

**Step 1: Run all backend tests**

```bash
cd /home/mato/projects/tools/package-tracker/backend && python -m pytest tests/ -v
```

Expected: ALL PASS

**Step 2: Run frontend type check and build**

```bash
cd /home/mato/projects/tools/package-tracker/frontend && npm run build
```

Expected: No type errors, successful build

**Step 3: Run ESLint**

```bash
cd /home/mato/projects/tools/package-tracker/frontend && npm run lint
```

Expected: No errors (auto-fix applied)

**Step 4: Docker compose up and verify**

```bash
cd /home/mato/projects/tools/package-tracker && docker compose up --build
```

- Verify migration runs on startup
- Navigate to Accounts page, verify mode badges appear
- Edit an account, verify "Use polling" toggle renders
- Check System Status dashboard, verify modes show correctly

**Step 5: Commit any final fixes**

```bash
git add -A
git commit -m "chore: fix any lint/build issues from IDLE redesign"
```
